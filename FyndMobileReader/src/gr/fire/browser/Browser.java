/*
 * Fire (Flexible Interface Rendering Engine) is a set of graphics widgets for creating GUIs for j2me applications. 
 * Copyright (C) 2006-2008 Bluevibe (www.bluevibe.net)
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 * 
 */

/**
 * 
 */
package gr.fire.browser;

import gr.fire.browser.util.HttpClient;
import gr.fire.browser.util.Page;
import gr.fire.browser.util.Request;
import gr.fire.core.CommandListener;
import gr.fire.core.Component;
import gr.fire.core.Container;
import gr.fire.core.FireScreen;
import gr.fire.core.Panel;
import gr.fire.ui.Alert;
import gr.fire.ui.ProgressbarAnimation;
import gr.fire.ui.TransitionAnimation;
import gr.fire.util.FireConnector;
import gr.fire.util.Lang;
import gr.fire.util.Log;
import gr.fire.util.StringUtil;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.util.Hashtable;
import java.util.Vector;

import javax.microedition.io.HttpConnection;
import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.Displayable;
import javax.microedition.lcdui.Font;

import org.kxml2.io.KXmlParser;

/**
 * The Browser Container parses HTML from a given stream and renders it.
 * It has some basic rendering rules that are choosen to improve the 
 * readability and usability of a page when rendered for a small screen. 
 * 
 * * The default width of the browser is the width of the screen
 *    
 * * TextPrimitive width is set as the width of the Browser unless noted otherwise
 *   by the style of the tag.
 *   
 * * TextPrimitive height is the height of the text calculated using the width 
 *   (according to the rules above) and the font of the text. 
 *   
 * * ImagePrimitive width is the width of the image unless noted otherwise by the style of the tag.
 * 
 *
 * @author padeler
 *
 */
public class Browser implements CommandListener
{
	
	/**
	 * Flag for the imageLoadingPolicy field. 
	 * No images are loaded.
	 */
	public static final byte NO_IMAGES=0x00; 
	/**
	 * Flag for the imageLoadingPolicy field. 
	 * Load images imediatelly
	 */
	public static final byte LOAD_IMAGES=0x01; 
	
	/**
	 * Flag for the imageLoadingPolicy field. 
	 * Load images in a seperate thread after the full parsing of the page. 
	 * The browser will return the Page object and start a thread to load the rest of the images.
	 * This will apply only for images that the width and height attributes are set.
	 * Images that do not have their width and height attributes set, will be loaded imediatelly.
	 */
	public static final byte LOAD_IMAGES_ASYNC=0x02;

	/**
	 * The listener that will receive the events generated by the page rendered by this browser (i.e. link clicks etc) 
	 * The listener will also receive the submit events generated by forms in the rendered pages. 
	 * If null, then the form handles the submit, with the default way (calls browser.displayPage()) 
	 */
	CommandListener listener = this; 
	
	/**
	 * If this field is set to false, then the browser will not request the images inside each page
	 */
	byte imageLoadingPolicy = LOAD_IMAGES_ASYNC;  
	
	/**
	 * The HttpClient used to request resources.
	 */
	HttpClient httpClient;
	
	private Hashtable knownTags = new Hashtable();
	
	private int viewportWidth=0; 
	
	
	/* ****** HTML Parsing support variables ******* */  
	private Vector tagStack = new Vector();
	private ProgressbarAnimation gauge=null;
	
	
	public Browser()
	{
		this(new HttpClient(new FireConnector()));
	}
	
	public Browser(HttpClient httpClient)
	{
		this.httpClient = httpClient; 
	}
	
	public void registerTag(String name,Class cl)
	{
		if(name!=null && cl!=null)
			knownTags.put(name,cl);
		else throw new NullPointerException("Tag name and class cannot be null");
	}
	
	private void showGauge(String message)
	{
		if(gauge!=null) hideGauge();
		
		gauge = new ProgressbarAnimation(message);
		
		Font font = FireScreen.getTheme().getFontProperty("titlebar.font");

		FireScreen screen = FireScreen.getScreen();
		int sw = screen.getWidth();
		int mw = font.stringWidth(message);
		gauge.setWidth(sw);
		gauge.setHeight(font.getHeight());
		screen.addComponent(gauge,5);
	}
	
	private void hideGauge()
	{
		if(gauge!=null){
			FireScreen.getScreen().removeComponent(gauge);
			gauge=null;
		}
	}

	
	public synchronized Page loadPage(String url,String method,Hashtable requestParameters,byte []data) throws UnsupportedEncodingException,IOException,Exception
	{
		
		if(url.startsWith("ttp://") || url.startsWith("ttps://"))
		{
			url = "h"+url;
			Log.logWarn("Malformed url resolved to: "+url);
		}
		
		Page page = new Page(url);

		/* ********** Display a gauge *************** */
		showGauge(StringUtil.proccessUrl(url,true));
		
		/* ************************** Request the resource **************************** */
		Request nextPage = null;
		try{
			nextPage = httpClient.requestResource(url,method,requestParameters,data,true);
			if(nextPage==null) {
				Log.logWarn("Failed to get resource from "+url);
				return null;
			}
			InputStream in = nextPage.getInputStream();
			if (in == null)
			{
				Log.logWarn("Failed to read data from "+url);
				return null;
			}
			
			Log.logDebug("Base URL is: "+nextPage.getBaseURL());
			String encoding= nextPage.getEncoding();
	
			return loadPageFromStream(page,in,encoding);
		}catch(Exception e){
			Log.logError("Failed to request page "+url+".",e);
			throw e;
		}finally{
			if(nextPage!=null) nextPage.close();
			hideGauge();
		}
	}
	
	public synchronized Page loadPage(InputStream in,String encoding) throws UnsupportedEncodingException,IOException,Exception
	{
		Page page = new Page();
		/* ********** Display a gauge *************** */
		showGauge("Loading...");
		try{
			return loadPageFromStream(page,in,encoding);
		}catch(Exception e){
			Log.logError("Failed to request page from stream.",e);
			throw e;
		}finally{
			hideGauge();
		}
	}
	
	private Page loadPageFromStream(Page page,InputStream in,String encoding) throws UnsupportedEncodingException,IOException,Exception
	{
		/* ******************************** clean old page stuff here **************************** */
		tagStack.removeAllElements();
		if(viewportWidth<=0)
		{
			viewportWidth = FireScreen.getScreen().getWidth();
		}
		gauge.progress();

		InputStreamReader reader=null;
		try{
			Log.logDebug("Using Encoding: "+encoding);
			reader = new InputStreamReader(in, encoding);
			
			KXmlParser parser = new KXmlParser();
			parser.setInput(reader);
			parser.setFeature(org.xmlpull.v1.XmlPullParser.FEATURE_RELAXED,true);

			int type;
		
			/* ********** Main XML parsing loop **************** */ 
			while ((type=parser.next()) != KXmlParser.END_DOCUMENT)
			{
				if(type==KXmlParser.START_TAG) /* **** Handle Opening TAGs ***** */
				{
					String name = parser.getName().toLowerCase();;
					Class tagClass = (Class)knownTags.get(name);
					if(tagClass!=null)
					{
						try
						{
							Tag t = (Tag)tagClass.newInstance();
							t.handleTagStart(this,page,parser);
							pushTag(t);
						}catch(InstantiationException e)
						{
							Log.logError("Failed to instantiate a Tag class for tag name "+name+".",e);
						} catch (Exception e)
						{
							Log.logError("Exception while handling tag start "+name,e);
						}
					}
					else Log.logWarn("Unknown Opening TAG "+name);
				}
				else if(type==KXmlParser.END_TAG) /* **** Handle Closing TAGs ***** */
				{
					String name = parser.getName().toLowerCase();;
					Tag t = (Tag)topTag();
					if(t!=null && name.equals(t.getName()))
					{
						t.handleTagEnd(this,page,parser);
						popTag();
					}
					else Log.logWarn("Unknown Closing TAG "+name);
				}
				else if(type==KXmlParser.TEXT) /* **** Handle Text inside a TAG ***** */
				{
					Tag top = (Tag)topTag();
					
					String txt = parser.getText();
					if(top!=null && txt.length()>0)
					{
						top.handleText(top,txt);
					}
				}
				else /* **** Default action, just log the unknown type and continue **** */
				{ 
					Log.logWarn("Unknown tag "+parser.getName() +" type " + type);
				}
			}
			
			gauge.progress();
			
			Log.logDebug("=>End Of Document<=");
			
		}finally{
			try{
				if(reader!=null) reader.close();
			}catch(Throwable e) {}	
		}
		
		if(imageLoadingPolicy==LOAD_IMAGES_ASYNC)
			page.startAsyncImageLoad(httpClient);
		
		return page;
	}
	
	/**
	 * When a Tag is pushed it is considered to be inside the last one pushed. 
	 * The Tag implementation is responsible for doing so.
	 *  
	 * @param node
	 */
	private void pushTag(Tag node)
	{
		tagStack.addElement(node);
	}
	
	public Tag topTag()
	{
		if(tagStack.size()>0)
			return (Tag)tagStack.lastElement();
		// else
		return null;
	}

	
	private Tag popTag()
	{
		int size = tagStack.size();
		if(size>0)
		{
			Tag tc = (Tag)tagStack.lastElement();
			tagStack.removeElementAt(size-1);
			
			if(size<=3) gauge.progress(); // easy (but not so aquare) method to show progress relative the parsing of the page... 
			
			return tc;
		}
		return null;
	}
		
	/* (non-Javadoc)
	 * @see gr.fire.core.CommandListener#commandAction(javax.microedition.lcdui.Command, gr.fire.core.Component)
	 */
	public void commandAction(Command command, Component c)
	{
		if(command instanceof gr.fire.browser.util.Command)
		{ // only handle known command types
			gr.fire.browser.util.Command cmd = (gr.fire.browser.util.Command)command;
			
			String url = cmd.getUrl();
			Component current = FireScreen.getScreen().getCurrent();
			Command left=null,right=null;
			if(current!=null)
			{
				left = current.getLeftSoftKeyCommand();
				right = current.getRightSoftKeyCommand();
				
			}
			displayPage(url,HttpConnection.GET,null,null,left,right,Panel.VERTICAL_SCROLLBAR|Panel.HORIZONTAL_SCROLLBAR,TransitionAnimation.TRANSITION_SCROLL|TransitionAnimation.TRANSITION_RIGHT);
		}
	}
	
	public void displayPage(final String url,final String method,final Hashtable requestParameters,final byte []data,final Command leftSoftKey,final Command rightSoftKey,final int scrollbarPolicy, final int transitionAnimation)
	{
		Thread th = new Thread()
		{
			public void run()
			{
				try
				{
					Page pageMeta  =loadPage(url,method,requestParameters,data);
					if(pageMeta!=null)
					{
						Container cnt = pageMeta.getPageContainer();
						String title= pageMeta.getPageTitle();
						Log.logInfo("Loaded Page ["+title+"]");
						Panel panel =null;
						if(cnt!=null)
						{
							panel = new Panel(cnt,scrollbarPolicy,true);
							panel.setLabel(title);
							
							panel.setLeftSoftKeyCommand(leftSoftKey);
							panel.setRightSoftKeyCommand(rightSoftKey);
							FireScreen screen = FireScreen.getScreen();
							Component last = screen.getCurrent();
							
							if(last!=null && transitionAnimation!=TransitionAnimation.TRANSITION_NONE) // show a transition animation
							{
								panel.setAnimation(new TransitionAnimation(last,panel,transitionAnimation));
							}
							
							FireScreen.getScreen().setCurrent(panel);
							panel.setCommandListener(listener);
							//panel.setDragScroll(true);
						}
						if(pageMeta.getRefresh()!=null)
						{
							int seconds = pageMeta.getRefreshSeconds();
							
							if(seconds>0) try{Thread.sleep(seconds*1000);}catch(InterruptedException e){}
							if(FireScreen.getScreen().getCurrent()==panel) // only execute refresh, if the user is still on the same page
							{
								displayPage(pageMeta.getRefresh(),HttpConnection.GET,null,null,leftSoftKey,rightSoftKey,scrollbarPolicy,transitionAnimation);
							}
							else 
							{
								Log.logWarn("Ignoring refresh to "+pageMeta.getRefresh() );
							}
						}
					}
					else 
					{// alert user
						String t=url;
						if(url.length()>15) t = url.substring(0,15)+"...";  
						Alert alert = new Alert(Lang.get("Failed to load page")+": "+t,Alert.TYPE_ERROR);
						FireScreen.getScreen().addComponent(alert,4);
					}
				} catch (Throwable e)
				{
					Log.logError("Request to URL ["+url+"] failed",e);
					Alert alert = new Alert(Lang.get("Error loading page.")+" "+e.getMessage(),Alert.TYPE_ERROR);
					FireScreen.getScreen().addComponent(alert,4);
				}
			}
		};
		th.start();
	}


	public void commandAction(Command cmd, Displayable d)
	{
	}

	public int getViewportWidth()
	{
		return viewportWidth;
	}
	
	public void setViewportWidth(int viewportWidth)
	{
		this.viewportWidth = viewportWidth;
	}

	public CommandListener getListener()
	{
		return listener;
	}

	public void setListener(CommandListener listener)
	{
		this.listener = listener;
	}

	public HttpClient getHttpClient()
	{
		return httpClient;
	}

	public void setHttpClient(HttpClient httpClient)
	{
		this.httpClient = httpClient;
	}

	public byte getImageLoadingPolicy()
	{
		return imageLoadingPolicy;
	}

	public void setImageLoadingPolicy(byte imageLoadingPolicy)
	{
		this.imageLoadingPolicy = imageLoadingPolicy;
	}
}